STRUCT NOCData {
    FIELD Bit(128) data
}
INTERFACE PipeIn {
    METHOD/Action enq__ENA ( NOCData v )
}
INTERFACE PipeInB {
    METHOD/Action enq__ENA ( Bit(32) v , Bit(16) length )
}
INTERFACE PipeInH {
    METHOD/Action enq__ENA ( NOCData v , Bit(16) length )
}
INTERFACE VBeat(width=32) {
    METHOD/Action beat__ENA ( Bit(32) v , Bit(1) last )
}
INTERFACE VsimInterface {
    FIELD/input Bit(1) CLK
    FIELD/input Bit(1) nRST
    FIELD/input Bit(1) CLK_derivedClock
    FIELD/input Bit(1) nRST_derivedReset
    FIELD/input Bit(1) CLK_sys_clk
}
EMODULE UserTop {
    INTERFACE PipeInB write
    INTERFACE/Ptr PipeInB read
}
EMODULE VsimReceive(width=32) {
    INTERFACE/Ptr VBeat(width=32) _
}
EMODULE VsimSend(width=32) {
    INTERFACE VBeat(width=32) _
}
EMODULE l_top {
    INTERFACE PipeIn request
    INTERFACE/Ptr PipeInH indication
}
MODULE VsimTop {
    INTERFACECONNECT readUser user$read PipeInB
    INTERFACECONNECT sink_0$_ writeUser VBeat(width=32)
    INTERFACE VsimInterface _
    INTERFACE PipeInB readUser
    FIELD UserTop user
    INTERFACE VBeat(width=32) writeUser
    FIELD VsimReceive(width=32) sink_0
    FIELD VsimSend(width=32) source_0
    METHOD/Action readUser$enq__ENA ( Bit(32) v , Bit(16) length ) {
        CALL/Action :source_0$beat__ENA{readUser$enq$v,(readUser$enq$length) == (1)}
    }
    METHOD/Action writeUser$beat__ENA ( Bit(32) v , Bit(1) last ) {
        CALL/Action :user$write$enq__ENA{writeUser$beat$v,(writeUser$beat$last) ? (1) : (2)}
    }
}
