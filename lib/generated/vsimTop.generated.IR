STRUCT NOCData  {
    FIELD Bit(128) data
}
INTERFACE PipeIn  {
    METHOD/Action enq__ENA ( NOCData v )
}
INTERFACE PipeInB  {
    METHOD/Action enq__ENA ( Bit(32) v , Bit(16) length )
}
INTERFACE PipeInH  {
    METHOD/Action enq__ENA ( NOCData v , Bit(16) length )
}
INTERFACE UserTopIfc  {
    INTERFACE PipeInB write
    INTERFACE/Ptr PipeInB read
}
INTERFACE VBeat(width=32)  {
    METHOD/Action beat__ENA ( Bit(32) v , Bit(1) last )
}
INTERFACE VBeatP(width=32)  {
    INTERFACE/Ptr VBeat(width=32) _
}
INTERFACE VsimInterface  {
    FIELD/input Bit(1) CLK
    FIELD/input Bit(1) nRST
    FIELD/input Bit(1) CLK_derivedClock
    FIELD/input Bit(1) nRST_derivedReset
    FIELD/input Bit(1) CLK_sys_clk
}
INTERFACE l_topIfc  {
    INTERFACE PipeIn request
    INTERFACE/Ptr PipeInH indication
}
EMODULE UserTop UserTopIfc {
}
EMODULE VsimReceive(width=32) VBeatP(width=32) {
}
EMODULE VsimSend(width=32) VBeat(width=32) {
}
EMODULE l_top l_topIfc {
}
MODULE VsimTop VsimInterface {
    INTERFACECONNECT writeUser sink_0$_ VBeat(width=32)
    INTERFACECONNECT readUser user$read PipeInB
    FIELD UserTop user
    FIELD VsimReceive(width=32) sink_0
    FIELD VsimSend(width=32) source_0
    INTERFACE VBeat(width=32) writeUser
    INTERFACE PipeInB readUser
    METHOD/Action readUser$enq__ENA ( Bit(32) v , Bit(16) length ) {
        CALL/Action :source_0$beat__ENA{readUser$enq$v,(readUser$enq$length) == (1)}
    }
    METHOD/Action writeUser$beat__ENA ( Bit(32) v , Bit(1) last ) {
        CALL/Action :user$write$enq__ENA{writeUser$beat$v,(writeUser$beat$last) ? (1) : (2)}
    }
}
