EMODULE l_struct_OC_NOCData {
    FIELD/Count 4  INTEGER_32 data
}
EMODULE l_ainterface_OC_PipeIn {
    METHOD enq__ENA ( l_struct_OC_NOCData v )
}
EMODULE l_ainterface_OC_PipeInB {
    METHOD enq__ENA ( INTEGER_32 v , INTEGER_16 length )
}
EMODULE l_ainterface_OC_PipeInH {
    METHOD enq__ENA ( l_struct_OC_NOCData v , INTEGER_16 length )
}
MODULE AdapterFromBus {
    INTERFACE l_ainterface_OC_PipeInB in
    INTERFACE/Ptr l_ainterface_OC_PipeInH out
    FIELD INTEGER_1 waitForEnq
    FIELD INTEGER_128 buffer
    METHOD/Rule RULEpushValue__ENA if ((waitForEnq)) {
        ALLOCA l_struct_OC_NOCData RULEpushValue__ENA$agg_2e_tmp
        LET INTEGER_128 :RULEpushValue__ENA$agg_2e_tmp = buffer
        CALL/Action :out$enq__ENA{RULEpushValue__ENA$agg_2e_tmp,0}
        STORE :waitForEnq = 0
    }
    METHOD in$enq__ENA ( INTEGER_32 v , INTEGER_16 length ) if (((waitForEnq) ^ (1))) {
        STORE :buffer = __bitconcat{__bitsubstr{buffer,95,0},in$enq$v}
        STORE ((in$enq$length) == (1)):waitForEnq = 1
    }
}
MODULE AdapterToBus {
    INTERFACE l_ainterface_OC_PipeInH in
    INTERFACE/Ptr l_ainterface_OC_PipeInB out
    FIELD INTEGER_16 remain
    FIELD INTEGER_128 buffer
    METHOD/Rule RULEcopyRule__ENA if (((remain) != (0))) {
        CALL/Action :out$enq__ENA{buffer,remain}
        STORE :remain = (remain) + (-1)
        STORE :buffer = (buffer) >> (32)
    }
    METHOD in$enq__ENA ( l_struct_OC_NOCData v , INTEGER_16 length ) if (((remain) == (0))) {
        STORE :buffer = in$enq$v
        STORE :remain = (in$enq$length) + (1)
    }
}
