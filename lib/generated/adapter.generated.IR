STRUCT NOCData  {
    FIELD Bit(128) data
}
INTERFACE AfB(width=32)  {
    INTERFACE PipeInB(width=32) in
    INTERFACE/Ptr PipeInH out
}
INTERFACE AtB(width=32)  {
    INTERFACE PipeInH in
    INTERFACE/Ptr PipeInB(width=32) out
}
INTERFACE PipeInB(width=32)  {
    METHOD/Action enq__ENA ( Bit(width) v , Bit(1) last )
}
INTERFACE PipeInH  {
    METHOD/Action enq__ENA ( NOCData v , Bit(16) length )
}
MODULE AdapterFromBus(width=32) AfB(width=32) {
    FIELD Bit(128) buffer
    FIELD Bit(1) waitForEnq
    METHOD/Action in$enq__ENA ( Bit(width) v , Bit(1) last ) if (((waitForEnq) ^ (1))) {
        STORE :buffer = __bitconcat{__bitsubstr{buffer,((128) - (32)) - (1),0},in$enq$v}
        STORE (in$enq$last):waitForEnq = (1) != (0)
    }
    METHOD/Rule/Action RULE$pushValue__ENA if ((waitForEnq)) {
        ALLOCA NOCData RULE$pushValue$agg_2e_tmp
        LET Bit(128) :RULE$pushValue$agg_2e_tmp = buffer
        CALL/Action :out$enq__ENA{RULE$pushValue$agg_2e_tmp,0}
        STORE :waitForEnq = (0) != (0)
    }
}
MODULE AdapterToBus(width=32) AtB(width=32) {
    FIELD Bit(128) buffer
    FIELD Bit(16) remain
    METHOD/Action in$enq__ENA ( NOCData v , Bit(16) length ) if (((remain) == (0))) {
        STORE :buffer = in$enq$v
        STORE :remain = in$enq$length
    }
    METHOD/Rule/Action RULE$copyRule__ENA if (((remain) != (0))) {
        CALL/Action :out$enq__ENA{buffer,(remain) == (1)}
        STORE :remain = (remain) + (-1)
        STORE :buffer = (buffer) >> (32)
    }
}
