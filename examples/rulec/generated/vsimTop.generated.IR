EMODULE l_struct_OC_NOCData {
    FIELD/Count 4  INTEGER_32 data
}
EMODULE l_ainterface_OC_MResetInverterResetInverter {
    FIELD/input INTEGER_1 RESET_IN
    FIELD/output INTEGER_1 RESET_OUT
}
EMODULE l_ainterface_OC_PipeIn {
    METHOD enq__ENA ( l_struct_OC_NOCData v )
}
EMODULE l_ainterface_OC_PipeInB {
    METHOD enq__ENA ( INTEGER_32 v , INTEGER_16 length )
}
EMODULE l_ainterface_OC_PipeOut {
    METHOD deq__ENA
    METHOD first l_struct_OC_NOCData
}
EMODULE l_ainterface_OC_VBeat {
    METHOD beat__ENA ( INTEGER_32 v , INTEGER_1 last )
}
EMODULE l_ainterface_OC_VsimInterface {
    FIELD/input INTEGER_1 CLK
    FIELD/input INTEGER_1 nRST
    FIELD/input INTEGER_1 CLK_derivedClock
    FIELD/input INTEGER_1 nRST_derivedReset
}
EMODULE Fifo {
    INTERFACE l_ainterface_OC_PipeIn in
    INTERFACE l_ainterface_OC_PipeOut out
}
EMODULE UserTop {
    INTERFACE l_ainterface_OC_PipeInB write
    INTERFACE/Ptr l_ainterface_OC_PipeInB read
}
EMODULE VsimReceive {
    INTERFACE/Ptr l_ainterface_OC_VBeat _
}
EMODULE VsimSend {
    INTERFACE l_ainterface_OC_VBeat _
}
MODULE Fifo1 {
    INTERFACE l_ainterface_OC_PipeIn in
    INTERFACE l_ainterface_OC_PipeOut out
    FIELD l_struct_OC_NOCData element
    FIELD INTEGER_1 full
    METHOD in$enq__ENA ( l_struct_OC_NOCData v ) if (((full) ^ (1))) {
        STORE :element = in$enq$v
        STORE :full = 1
    }
    METHOD out$deq__ENA if ((full)) {
        STORE :full = 0
    }
    METHOD out$first l_struct_OC_NOCData = ((out$first$retval)) if ((full)) {
        ALLOCA l_struct_OC_NOCData out$first$retval
        LET l_struct_OC_NOCData :out$first$retval = element
    }
}
MODULE MuxPipe {
    INTERFACE l_ainterface_OC_PipeIn in
    INTERFACE l_ainterface_OC_PipeIn forward
    INTERFACE/Ptr l_ainterface_OC_PipeIn out
    FIELD Fifo1 forwardFifo
    METHOD/Rule RULEfifoRule__ENA {
        ALLOCA l_struct_OC_NOCData RULEfifoRule__ENA$agg_2e_tmp
        CALL :forwardFifo$out$first{}
        LET l_struct_OC_NOCData :RULEfifoRule__ENA$agg_2e_tmp = forwardFifo$out$first
        CALL/Action :out$enq__ENA{RULEfifoRule__ENA$agg_2e_tmp}
        CALL/Action :forwardFifo$out$deq__ENA{}
    }
    METHOD forward$enq__ENA ( l_struct_OC_NOCData v ) {
        CALL/Action :forwardFifo$in$enq__ENA{forward$enq$v}
    }
    METHOD in$enq__ENA ( l_struct_OC_NOCData v ) {
        CALL/Action :out$enq__ENA{in$enq$v}
    }
}
MODULE ResetInverter {
    INTERFACE l_ainterface_OC_MResetInverterResetInverter _
}
MODULE VsimTop {
    INTERFACECONNECT readUser user$read l_ainterface_OC_PipeInB
    INTERFACECONNECT sink_0$_ writeUser l_ainterface_OC_VBeat
    INTERFACE l_ainterface_OC_VsimInterface _
    INTERFACE l_ainterface_OC_PipeInB readUser
    FIELD UserTop user
    INTERFACE l_ainterface_OC_VBeat writeUser
    FIELD VsimReceive sink_0
    FIELD VsimSend source_0
    METHOD readUser$enq__ENA ( INTEGER_32 v , INTEGER_16 length ) {
        CALL/Action :source_0$beat__ENA{readUser$enq$v,(readUser$enq$length) == (1)}
    }
    METHOD writeUser$beat__ENA ( INTEGER_32 v , INTEGER_1 last ) {
        CALL/Action :user$write$enq__ENA{writeUser$beat$v,(writeUser$beat$last) ? (1) : (2)}
    }
}
