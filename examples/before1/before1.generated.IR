EMODULE l_struct_OC_EchoIndication_data {
    FIELD tag INTEGER_32
    FIELD data l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoIndication_union
}
EMODULE l_struct_OC_EchoRequest_data {
    FIELD tag INTEGER_32
    FIELD data l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoRequest_union
}
EMODULE l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoIndication_union {
    FIELD heard l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoIndication_union_KD__KD_EchoIndication_heard
}
EMODULE l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoIndication_union_KD__KD_EchoIndication_heard {
    FIELD meth INTEGER_32
    FIELD v INTEGER_32
}
EMODULE l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoRequest_union {
    FIELD say l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoRequest_union_KD__KD_EchoRequest_say
    FIELD say2 l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoRequest_union_KD__KD_EchoRequest_say2
}
EMODULE l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoRequest_union_KD__KD_EchoRequest_say {
    FIELD meth INTEGER_32
    FIELD v INTEGER_32
}
EMODULE l_struct_OC__IC_anonymous_AC_struct_JC__KD__KD_EchoRequest_union_KD__KD_EchoRequest_say2 {
    FIELD meth INTEGER_32
    FIELD v INTEGER_32
    FIELD v2 INTEGER_32
}
EMODULE l_ainterface_OC_EchoIndication {
    METHOD heard__ENA ( INTEGER_32 meth , INTEGER_32 v )
}
EMODULE l_ainterface_OC_EchoRequest {
    METHOD say2__ENA ( INTEGER_32 meth , INTEGER_32 v )
    METHOD say__ENA ( INTEGER_32 meth , INTEGER_32 v )
}
EMODULE l_ainterface_OC_PipeIn {
    METHOD enq__ENA ( l_struct_OC_EchoRequest_data v )
}
EMODULE l_ainterface_OC_PipeIn_OC_0 {
    METHOD enq__ENA ( l_struct_OC_EchoIndication_data v )
}
EMODULE l_ainterface_OC_Swap {
    METHOD x2y__ENA
    METHOD y2x__ENA
    METHOD y2xnull__ENA
}
MODULE l_module_OC_Connect {
    SOFTWARE request
    SOFTWARE indication
    INTERFACECONNECT lERI$request lEcho$request l_ainterface_OC_EchoRequest
    INTERFACECONNECT lEIO$pipe lEII_test$pipe l_ainterface_OC_PipeIn_OC_0
    INTERFACECONNECT lEcho$indication lEIO$indication l_ainterface_OC_EchoIndication
    INTERFACECONNECT lERO_test$pipe lERI$pipe l_ainterface_OC_PipeIn
    INTERFACECONNECT lEII_test$indication indication l_ainterface_OC_EchoIndication
    INTERFACE request l_ainterface_OC_EchoRequest
    EINTERFACE indication l_ainterface_OC_EchoIndication
    FIELD lEIO l_module_OC_EchoIndicationOutput
    FIELD lERI l_module_OC_EchoRequestInput
    FIELD lEcho l_module_OC_Echo
    FIELD lERO_test l_module_OC_EchoRequestOutput
    FIELD lEII_test l_module_OC_EchoIndicationInput
    METHOD request$say2__ENA ( INTEGER_32 meth , INTEGER_32 v ) {
        CALL/Action :lERO_test$request$say2__ENA{request$say2$meth,request$say2$v}
    }
    METHOD request$say__ENA ( INTEGER_32 meth , INTEGER_32 v ) {
        CALL/Action :lERO_test$request$say__ENA{request$say$meth,request$say$v}
    }
    METHOD/Rule swap2_rule__ENA {
        CALL/Action :lEcho$swap$y2xnull__ENA{}
    }
    METHOD/Rule swap_rule__ENA {
        CALL/Action :lEcho$swap$x2y__ENA{}
        CALL/Action :lEcho$swap$y2x__ENA{}
    }
}
MODULE l_module_OC_Echo {
    INTERFACE request l_ainterface_OC_EchoRequest
    INTERFACE swap l_ainterface_OC_Swap
    FIELD busy INTEGER_32
    FIELD meth_temp INTEGER_32
    FIELD v_temp INTEGER_32
    FIELD busy_delay INTEGER_32
    FIELD meth_delay INTEGER_32
    FIELD v_delay INTEGER_32
    FIELD x INTEGER_32
    FIELD y INTEGER_32
    EINTERFACE indication l_ainterface_OC_EchoIndication
    METHOD/Rule delay_rule__ENA if (((busy != 0) & (busy_delay == 0)) != 0) {
        STORE :busy = 0
        STORE :busy_delay = 1
        STORE :meth_delay = meth_temp
        STORE :v_delay = v_temp
    }
    METHOD request$say2__ENA ( INTEGER_32 meth , INTEGER_32 v ) if ((busy != 0) ^ 1) {
        STORE :meth_temp = request$say2$meth
        STORE :v_temp = request$say2$v
        STORE :busy = 1
    }
    METHOD request$say__ENA ( INTEGER_32 meth , INTEGER_32 v ) if ((busy != 0) ^ 1) {
        STORE :meth_temp = request$say$meth
        STORE :v_temp = request$say$v
        STORE :busy = 1
    }
    METHOD/Rule respond_rule__ENA if (busy_delay != 0) {
        STORE :busy_delay = 0
        CALL/Action :indication$heard__ENA{meth_delay,v_delay}
    }
    METHOD swap$x2y__ENA {
        STORE :y = x
    }
    METHOD swap$y2x__ENA {
        STORE :x = y
    }
    METHOD swap$y2xnull__ENA
}
MODULE l_module_OC_EchoIndicationInput {
    INTERFACE pipe l_ainterface_OC_PipeIn_OC_0
    EINTERFACE indication l_ainterface_OC_EchoIndication
    FIELD busy_delay INTEGER_32
    FIELD meth_delay INTEGER_32
    FIELD v_delay INTEGER_32
    METHOD/Rule input_rule__ENA if (busy_delay != 0) {
        STORE :busy_delay = 0
        CALL/Action :indication$heard__ENA{meth_delay,v_delay}
    }
    METHOD pipe$enq__ENA ( l_struct_OC_EchoIndication_data v ) if ((busy_delay != 0) ^ 1) {
        ALLOCA pipe$enq__ENA$v_2e_addr l_struct_OC_EchoIndication_data
        LET l_struct_OC_EchoIndication_data :pipe$enq__ENA$v_2e_addr = pipe$enq$v
        STORE (pipe$enq__ENA$v_2e_addr6$tag == 1):meth_delay = pipe$enq__ENA$v_2e_addr$data$heard$meth
        STORE (pipe$enq__ENA$v_2e_addr6$tag == 1):v_delay = pipe$enq__ENA$v_2e_addr$data$heard$v
        STORE (pipe$enq__ENA$v_2e_addr6$tag == 1):busy_delay = 1
    }
}
MODULE l_module_OC_EchoIndicationOutput {
    INTERFACE indication l_ainterface_OC_EchoIndication
    EINTERFACE pipe l_ainterface_OC_PipeIn_OC_0
    FIELD ind0 l_struct_OC_EchoIndication_data
    FIELD ind1 l_struct_OC_EchoIndication_data
    FIELD ind_busy INTEGER_32
    FIELD even INTEGER_32
    METHOD indication$heard__ENA ( INTEGER_32 meth , INTEGER_32 v ) if ((ind_busy != 0) ^ 1) {
        STORE (even != 0):ind1$tag = 1
        STORE (even != 0):ind1$data$heard$meth = indication$heard$meth
        STORE (even != 0):ind1$data$heard$v = indication$heard$v
        STORE ((even != 0) ^ 1):ind0$tag = 1
        STORE ((even != 0) ^ 1):ind0$data$heard$meth = indication$heard$meth
        STORE ((even != 0) ^ 1):ind0$data$heard$v = indication$heard$v
        STORE :ind_busy = 1
        STORE :even = (even != 0) ^ 1
    }
    METHOD/Rule output_rulee__ENA if (((ind_busy != 0) & (even != 0)) != 0) {
        STORE :ind_busy = 0
        CALL/Action :pipe$enq__ENA{ind0}
    }
    METHOD/Rule output_ruleo__ENA if (((ind_busy != 0) & (even == 0)) != 0) {
        STORE :ind_busy = 0
        CALL/Action :pipe$enq__ENA{ind1}
    }
}
MODULE l_module_OC_EchoRequestInput {
    INTERFACE pipe l_ainterface_OC_PipeIn
    EINTERFACE request l_ainterface_OC_EchoRequest
    METHOD pipe$enq__ENA ( l_struct_OC_EchoRequest_data v ) {
        ALLOCA pipe$enq__ENA$v_2e_addr l_struct_OC_EchoRequest_data
        LET l_struct_OC_EchoRequest_data :pipe$enq__ENA$v_2e_addr = pipe$enq$v
        CALL/Action (pipe$enq__ENA$v_2e_addr13$tag == 1):request$say__ENA{pipe$enq__ENA$v_2e_addr$data$say$meth,pipe$enq__ENA$v_2e_addr$data$say$v}
        CALL/Action (pipe$enq__ENA$v_2e_addr15$tag == 2):request$say2__ENA{pipe$enq__ENA$v_2e_addr$data$say2$meth,pipe$enq__ENA$v_2e_addr$data$say2$v}
    }
}
MODULE l_module_OC_EchoRequestOutput {
    INTERFACE request l_ainterface_OC_EchoRequest
    EINTERFACE pipe l_ainterface_OC_PipeIn
    METHOD request$say2__ENA ( INTEGER_32 meth , INTEGER_32 v ) {
        ALLOCA request$say2__ENA$ind l_struct_OC_EchoRequest_data
        LET INTEGER_32 :request$say2__ENA$ind$tag = 2
        STORE :request$say2__ENA$ind$data$say2$meth = request$say2$meth
        STORE :request$say2__ENA$ind$data$say2$v = request$say2$v
        CALL/Action :pipe$enq__ENA{request$say2__ENA$ind}
    }
    METHOD request$say__ENA ( INTEGER_32 meth , INTEGER_32 v ) {
        ALLOCA request$say__ENA$ind l_struct_OC_EchoRequest_data
        LET INTEGER_32 :request$say__ENA$ind$tag = 1
        STORE :request$say__ENA$ind$data$say$meth = request$say$meth
        STORE :request$say__ENA$ind$data$say$v = request$say$v
        CALL/Action :pipe$enq__ENA{request$say__ENA$ind}
    }
}
