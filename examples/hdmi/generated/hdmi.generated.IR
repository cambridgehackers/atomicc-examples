STRUCT NOCDataH  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
    FIELD Bit(16) length
    FIELD Bit(128) data
}
INTERFACE AsyncControlIfc  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
    FIELD/input Bit(1) CLK
    FIELD/input Bit(1) nRST
    FIELD/input Bit(1) start
    FIELD/input Bit(1) end
    FIELD/input Bit(1) clear
    FIELD/output Bit(1) out
    FIELD/output Bit(1) done
}
INTERFACE ClockImageonIfc  {
    FILE hdmi_OC_cpp
    FIELD/input Bit(1) CLK
    FIELD/input Bit(1) nRST
    FIELD/output Bit(1) hdmiClock
    FIELD/output Bit(1) imageonClock
}
INTERFACE EchoIfc  {
    FILE hdmi_OC_cpp
    SOFTWARE request
    SOFTWARE indication
    INTERFACE EchoRequest request
    INTERFACE/Ptr EchoIndication indication
    FIELD/input Bit(1) CLK
    FIELD/input Bit(1) nRST
    FIELD/input Bit(1) fmc_video_clk1_v
    FIELD/output Bit(1) i2c_mux_reset_n
    FIELD/output Bit(1) adv7511_clk
    FIELD/output Bit(36) adv7511_d
    FIELD/output Bit(1) adv7511_de
    FIELD/output Bit(1) adv7511_hs
    FIELD/output Bit(1) adv7511_vs
}
INTERFACE EchoIndication  {
    FILE hdmi_OC_cpp
    METHOD/Action heard__ENA ( Bit(32) v )
    METHOD/Action heard2__ENA ( Bit(16) a , Bit(16) b )
    METHOD/Action heard3__ENA ( Bit(16) a , Bit(32) b , Bit(32) c , Bit(16) d )
}
INTERFACE EchoRequest  {
    FILE hdmi_OC_cpp
    METHOD/Action say__ENA ( Bit(32) v )
    METHOD/Action muxreset__ENA ( Bit(1) v )
    METHOD/Action setLeds__ENA ( Bit(8) v )
    METHOD/Action setup__ENA ( Bit(16) ahEnd , Bit(16) ahFrontEnd , Bit(8) ahBackSync , Bit(8) ahSyncWidth , Bit(16) avEnd , Bit(16) avFrontEnd , Bit(8) avBackSync , Bit(8) avSyncWidth )
}
INTERFACE Fifo(width=1)  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_fifo_OC_h
    INTERFACE PipeIn(width=1) in
    INTERFACE PipeOut(width=1) out
}
INTERFACE HdmiBlockIfc  {
    FILE hdmi_OC_cpp
    FIELD/input Bit(1) CLK
    FIELD/input Bit(1) nRST
    FIELD/output Bit(36) adv7511_d
    FIELD/output Bit(1) adv7511_de
    FIELD/output Bit(1) adv7511_hs
    FIELD/output Bit(1) adv7511_vs
    METHOD/Action/Async setup__ENA ( Bit(16) ahEnd , Bit(16) ahFrontEnd , Bit(8) ahBackSync , Bit(8) ahSyncWidth , Bit(16) avEnd , Bit(16) avFrontEnd , Bit(8) avBackSync , Bit(8) avSyncWidth )
}
INTERFACE HdmiDataIfc(widthAddr=12,heightAddr=12)  {
    FILE hdmi_OC_cpp
    METHOD/Action setXY__ENA ( Bit(widthAddr) x , Bit(heightAddr) y , Bit(1) dataEnable )
}
INTERFACE HdmiDataIfc(widthAddr=12,heightAddr=13)  {
    FILE hdmi_OC_cpp
    METHOD/Action setXY__ENA ( Bit(widthAddr) x , Bit(heightAddr) y , Bit(1) dataEnable )
}
INTERFACE HdmiPatternIfc(widthAddr=12,heightAddr=12)  {
    FILE hdmi_OC_cpp
    INTERFACE HdmiDataIfc(widthAddr=12,heightAddr=12) calculate
    METHOD/Action setup__ENA ( Bit(widthAddr) aactivePixels , Bit(heightAddr) aactiveLines , Bit(8) apattern , Bit(20) arampStep )
    METHOD data Bit(36)
}
INTERFACE HdmiSyncIfc(widthAddr=12,heightAddr=12)  {
    FILE hdmi_OC_cpp
    INTERFACE/Ptr HdmiDataIfc(widthAddr=12,heightAddr=12) data
    METHOD dataEnable Bit(1)
    METHOD hSync Bit(1)
    METHOD vSync Bit(1)
    METHOD/Action setup__ENA ( Bit(widthAddr) ahEnd , Bit(widthAddr) ahFrontEnd , Bit(widthAddr) ahBackSync , Bit(widthAddr) ahSyncWidth , Bit(heightAddr) avEnd , Bit(heightAddr) avFrontEnd , Bit(heightAddr) avBackSync , Bit(heightAddr) avSyncWidth )
}
INTERFACE MResetInverterResetInverter  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_VResetInverter_OC_h
    FIELD/input Bit(1) RESET_IN
    FIELD/output Bit(1) RESET_OUT
}
INTERFACE MbufgBUFG  {
    FILE _OC__OC__PC__OC__OC__PC_xilinx_PC_VBUFG_OC_h
    FIELD/input Bit(1) I
    FIELD/output Bit(1) O
}
INTERFACE Mmcme2MMCME2_ADV  {
    FILE _OC__OC__PC__OC__OC__PC_xilinx_PC_VMMCME2_PF_ADV_OC_h
    FIELD/Ptr/parameter Bit(8) BANDWIDTH
    FIELD/input Bit(1) CLKFBIN
    FIELD/output Bit(1) CLKFBOUT
    FIELD/output Bit(1) CLKFBOUTB
    FIELD/parameter FLOAT CLKFBOUT_MULT_F
    FIELD/parameter FLOAT CLKFBOUT_PHASE
    FIELD/Ptr/parameter Bit(8) CLKFBOUT_USE_FINE_PS
    FIELD/output Bit(1) CLKFBSTOPPED
    FIELD/input Bit(1) CLKIN1
    FIELD/parameter FLOAT CLKIN1_PERIOD
    FIELD/input Bit(1) CLKIN2
    FIELD/parameter FLOAT CLKIN2_PERIOD
    FIELD/input Bit(1) CLKINSEL
    FIELD/output Bit(1) CLKINSTOPPED
    FIELD/output Bit(1) CLKOUT0
    FIELD/output Bit(1) CLKOUT0B
    FIELD/parameter FLOAT CLKOUT0_DIVIDE_F
    FIELD/parameter FLOAT CLKOUT0_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT0_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT0_USE_FINE_PS
    FIELD/output Bit(1) CLKOUT1
    FIELD/output Bit(1) CLKOUT1B
    FIELD/parameter Bit(32) CLKOUT1_DIVIDE
    FIELD/parameter FLOAT CLKOUT1_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT1_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT1_USE_FINE_PS
    FIELD/output Bit(1) CLKOUT2
    FIELD/output Bit(1) CLKOUT2B
    FIELD/parameter Bit(32) CLKOUT2_DIVIDE
    FIELD/parameter FLOAT CLKOUT2_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT2_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT2_USE_FINE_PS
    FIELD/output Bit(1) CLKOUT3
    FIELD/output Bit(1) CLKOUT3B
    FIELD/parameter Bit(32) CLKOUT3_DIVIDE
    FIELD/parameter FLOAT CLKOUT3_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT3_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT3_USE_FINE_PS
    FIELD/output Bit(1) CLKOUT4
    FIELD/Ptr/parameter Bit(8) CLKOUT4_CASCADE
    FIELD/parameter Bit(32) CLKOUT4_DIVIDE
    FIELD/parameter FLOAT CLKOUT4_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT4_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT4_USE_FINE_PS
    FIELD/output Bit(1) CLKOUT5
    FIELD/parameter Bit(32) CLKOUT5_DIVIDE
    FIELD/parameter FLOAT CLKOUT5_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT5_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT5_USE_FINE_PS
    FIELD/output Bit(1) CLKOUT6
    FIELD/parameter Bit(32) CLKOUT6_DIVIDE
    FIELD/parameter FLOAT CLKOUT6_DUTY_CYCLE
    FIELD/parameter FLOAT CLKOUT6_PHASE
    FIELD/Ptr/parameter Bit(8) CLKOUT6_USE_FINE_PS
    FIELD/Ptr/parameter Bit(8) COMPENSATION
    FIELD/input Bit(7) DADDR
    FIELD/input Bit(1) DCLK
    FIELD/input Bit(1) DEN
    FIELD/input Bit(16) DI
    FIELD/parameter Bit(32) DIVCLK_DIVIDE
    FIELD/output Bit(16) DO
    FIELD/output Bit(1) DRDY
    FIELD/input Bit(1) DWE
    FIELD/parameter Bit(32) IS_CLKINSEL_INVERTED
    FIELD/parameter Bit(32) IS_PSEN_INVERTED
    FIELD/parameter Bit(32) IS_PSINCDEC_INVERTED
    FIELD/parameter Bit(32) IS_PWRDWN_INVERTED
    FIELD/parameter Bit(32) IS_RST_INVERTED
    FIELD/output Bit(1) LOCKED
    FIELD/input Bit(1) PSCLK
    FIELD/output Bit(1) PSDONE
    FIELD/input Bit(1) PSEN
    FIELD/input Bit(1) PSINCDEC
    FIELD/input Bit(1) PWRDWN
    FIELD/parameter FLOAT REF_JITTER1
    FIELD/parameter FLOAT REF_JITTER2
    FIELD/input Bit(1) RST
    FIELD/Ptr/parameter Bit(8) SS_EN
    FIELD/Ptr/parameter Bit(8) SS_MODE
    FIELD/parameter Bit(32) SS_MOD_PERIOD
    FIELD/Ptr/parameter Bit(8) STARTUP_WAIT
}
INTERFACE PipeIn(width=32)  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
    METHOD/Action enq__ENA ( Bit(width) v )
}
INTERFACE PipeOut(width=1)  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
    METHOD/Action deq__ENA
    METHOD first Bit(width)
}
INTERFACE SelectIndexIfc(funnelWidth=20,width=14)  {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
    FIELD Bit(14) out
    FIELD/Ptr/Count funnelWidth  Bit(14) in
    FIELD Bit(5) index
}
EMODULE AsyncControl AsyncControlIfc {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
}
EMODULE BUFG MbufgBUFG {
    FILE _OC__OC__PC__OC__OC__PC_xilinx_PC_VBUFG_OC_h
}
EMODULE Dummy PipeIn(width=32) {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
}
EMODULE Fifo1Base(width=1) Fifo(width=1) {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_fifo_OC_h
}
EMODULE MMCME2_ADV Mmcme2MMCME2_ADV {
    FILE _OC__OC__PC__OC__OC__PC_xilinx_PC_VMMCME2_PF_ADV_OC_h
}
EMODULE ResetInverter MResetInverterResetInverter {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_resetInverter_OC_h
}
EMODULE/Verilog SelectIndex(funnelWidth=20,width=14) SelectIndexIfc(funnelWidth=20,width=14) {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_atomicc_OC_h
}
MODULE ClockImageon ClockImageonIfc {
    FILE hdmi_OC_cpp
    FIELD MMCME2_ADV imageon_pll
    PARAMS imageon_pll REF_JITTER2=0.01,REF_JITTER1=0.01,CLKOUT2_PHASE=0.0,CLKOUT2_DUTY_CYCLE=0.5,CLKOUT2_DIVIDE=1,CLKOUT1_PHASE=0.0,CLKOUT1_DUTY_CYCLE=0.5,CLKOUT1_DIVIDE=32,CLKOUT0_PHASE=0.0,CLKOUT0_DUTY_CYCLE=0.5,CLKOUT0_DIVIDE_F=8.0,DIVCLK_DIVIDE=1,CLKIN2_PERIOD=6.7340070000000001,CLKIN1_PERIOD=10.0,CLKFBOUT_PHASE=0.0,CLKFBOUT_MULT_F=8.0,STARTUP_WAIT="FALSE",COMPENSATION="ZHOLD",CLKOUT4_CASCADE="FALSE",CLKOUT2_USE_FINE_PS="FALSE",CLKOUT1_USE_FINE_PS="FALSE",CLKOUT0_USE_FINE_PS="FALSE",CLKFBOUT_USE_FINE_PS="FALSE",BANDWIDTH="OPTIMIZED"
    FIELD ResetInverter rinverter
    FIELD BUFG fbclockb
    FIELD BUFG hdmi_clockb
    FIELD BUFG imageon_clockb
    METHOD/Rule/Action RULE$init__ENA {
        LET Bit(1) :rinverter$RESET_IN = nRST
        LET Bit(1) :imageon_pll$CLKIN2 = 0
        LET Bit(1) :imageon_pll$CLKINSEL = 1
        LET Bit(7) :imageon_pll$DADDR = 0
        LET Bit(1) :imageon_pll$DCLK = 0
        LET Bit(1) :imageon_pll$DEN = 0
        LET Bit(16) :imageon_pll$DI = 0
        LET Bit(1) :imageon_pll$DWE = 0
        LET Bit(1) :imageon_pll$PSCLK = 0
        LET Bit(1) :imageon_pll$PSEN = 0
        LET Bit(1) :imageon_pll$PSINCDEC = 0
        LET Bit(1) :imageon_pll$PWRDWN = 0
        LET Bit(1) :fbclockb$I = imageon_pll$CLKFBOUT
        LET Bit(1) :imageon_pll$CLKFBIN = fbclockb$O
        LET Bit(1) :imageon_pll$RST = rinverter$RESET_OUT
        LET Bit(1) :imageon_pll$CLKIN1 = __defaultClock
        LET Bit(1) :hdmi_clockb$I = imageon_pll$CLKOUT0
        LET Bit(1) :hdmiClock = hdmi_clockb$O
        LET Bit(1) :imageon_clockb$I = imageon_pll$CLKOUT1
        LET Bit(1) :imageonClock = imageon_clockb$O
    }
}
MODULE Echo EchoIfc {
    FILE hdmi_OC_cpp
    FIELD ClockImageon iclock
    FIELD HdmiBlock hdmi
    FIELD Fifo1(width=1) bozo
    FIELD Bit(1) i2c_mux_reset_n_reg
    FIELD Bit(1) busy
    FIELD Bit(1) busy_delay
    FIELD Bit(32) v_temp
    FIELD Bit(32) v_delay
    FIELD Bit(16) a_temp
    FIELD Bit(16) b_temp
    FIELD Bit(16) a_delay
    FIELD Bit(16) b_delay
    FIELD Bit(32) v_type
    METHOD/Rule/Action RULE$initHdmi__ENA {
        LET Bit(1) :iclock$CLK = fmc_video_clk1_v
        LET Bit(1) :iclock$nRST = __defaultnReset
        LET Bit(1) :hdmi$CLK = iclock$hdmiClock
        LET Bit(1) :hdmi$nRST = __defaultnReset
        LET Bit(1) :adv7511_clk = ((hdmi$CLK) != (0)) ^ (1)
        LET Bit(36) :adv7511_d = hdmi$adv7511_d
        LET Bit(1) :adv7511_de = hdmi$adv7511_de
        LET Bit(1) :adv7511_hs = hdmi$adv7511_hs
        LET Bit(1) :adv7511_vs = hdmi$adv7511_vs
        LET Bit(1) :i2c_mux_reset_n = i2c_mux_reset_n_reg
    }
    METHOD/Action request$say__ENA ( Bit(32) v ) if ((((busy) != (0)) ^ (1))) {
        PRINTF :printf{"request.say %x\n",request$say$v}
        STORE :v_temp = request$say$v
        STORE :busy = 1
        STORE :v_type = 1
    }
    METHOD/Action request$muxreset__ENA ( Bit(1) v ) {
        STORE :i2c_mux_reset_n_reg = request$muxreset$v
    }
    METHOD/Action request$setup__ENA ( Bit(16) ahEnd , Bit(16) ahFrontEnd , Bit(8) ahBackSync , Bit(8) ahSyncWidth , Bit(16) avEnd , Bit(16) avFrontEnd , Bit(8) avBackSync , Bit(8) avSyncWidth ) {
        CALL/Action/Async :hdmi$setup__ENA{request$setup$ahEnd,request$setup$ahFrontEnd,request$setup$ahBackSync,request$setup$ahSyncWidth,request$setup$avEnd,request$setup$avFrontEnd,request$setup$avBackSync,request$setup$avSyncWidth}
        CALL/Action :bozo$out$deq__ENA{}
        STORE :b_delay = 99
    }
    METHOD/Rule/Action RULE$delay_rule__ENA if (((((busy) != (0)) & ((busy_delay) == (0))) != (0))) {
        STORE :busy = 0
        STORE :busy_delay = 1
        STORE :v_delay = v_temp
        STORE :a_delay = a_temp
        STORE :b_delay = b_temp
    }
    METHOD/Rule/Action RULE$respond_rule__ENA if (((busy_delay) != (0))) {
        STORE :busy_delay = 0
        CALL/Action ((v_type) == (1)):indication$heard__ENA{v_delay}
        CALL/Action !((v_type) == (1)):indication$heard2__ENA{a_delay,b_delay}
    }
}
MODULE Fifo1(width=1) Fifo(width=1) {
    FILE _OC__OC__PC__OC__OC__PC_lib_PC_fifo_OC_h
    FIELD Fifo1Base(width=1) fifo
    METHOD/Action in$enq__ENA ( Bit(1) v ) {
        CALL/Action :fifo$in$enq__ENA{in$enq$v}
    }
    METHOD/Action out$deq__ENA {
        CALL/Action :fifo$out$deq__ENA{}
    }
    METHOD out$first Bit(1) = ((fifo$out$first)) {
        CALL :fifo$out$first{}
    }
}
MODULE HdmiBlock HdmiBlockIfc {
    FILE hdmi_OC_cpp
    INTERFACECONNECT syncBlock$data patternBlock$calculate HdmiDataIfc(widthAddr=12,heightAddr=12)
    FIELD HdmiSync(widthAddr=12,heightAddr=12) syncBlock
    FIELD HdmiPattern(widthAddr=12,heightAddr=12) patternBlock
    FIELD Bit(1) dataEnable
    FIELD Bit(1) hSync
    FIELD Bit(1) vSync
    FIELD Bit(1) once
    METHOD/Action/Async setup__ENA ( Bit(16) ahEnd , Bit(16) ahFrontEnd , Bit(8) ahBackSync , Bit(8) ahSyncWidth , Bit(16) avEnd , Bit(16) avFrontEnd , Bit(8) avBackSync , Bit(8) avSyncWidth ) if (((once) ^ (1))) {
        STORE :once = 1
    }
    METHOD/Rule/Action RULE$initHdmi__ENA {
        CALL :patternBlock$data{}
        LET Bit(36) :adv7511_d = patternBlock$data
        LET Bit(1) :adv7511_de = dataEnable
        LET Bit(1) :adv7511_hs = hSync
        LET Bit(1) :adv7511_vs = vSync
        CALL :syncBlock$dataEnable{}
        STORE :dataEnable = syncBlock$dataEnable
        CALL :syncBlock$hSync{}
        STORE :hSync = syncBlock$hSync
        CALL :syncBlock$vSync{}
        STORE :vSync = syncBlock$vSync
    }
    METHOD/Rule/Action RULE$init__ENA if (((once) ^ (1))) {
        CALL/Action :syncBlock$setup__ENA{(2200) - (1),((2200) - (1)) - (88),(148) + (44),44,(1125) - (1),((1125) - (1)) - (4),(36) + (5),5}
        CALL/Action :patternBlock$setup__ENA{(((2200) - (1)) - (88)) - ((148) + (44)),(((1125) - (1)) - (4)) - ((36) + (5)),4,546}
        STORE :once = 1
    }
}
MODULE HdmiData(widthAddr=12,heightAddr=13) HdmiDataIfc(widthAddr=12,heightAddr=13) {
    FILE hdmi_OC_cpp
    METHOD/Action setXY__ENA ( Bit(widthAddr) x , Bit(heightAddr) y , Bit(1) dataEnable )
}
MODULE HdmiPattern(widthAddr=12,heightAddr=12) HdmiPatternIfc(widthAddr=12,heightAddr=12) {
    FILE hdmi_OC_cpp
    FIELD Bit(36) pixelValue
    FIELD Bit((8 + 12)) rampValue
    FIELD Bit(12) activePixels
    FIELD Bit(12) activeLines
    FIELD Bit(8) pattern
    FIELD Bit((8 + 12)) rampStep
    METHOD/Action setup__ENA ( Bit(widthAddr) aactivePixels , Bit(heightAddr) aactiveLines , Bit(8) apattern , Bit((8 + 12)) arampStep ) {
        STORE :activePixels = setup$aactivePixels
        STORE :activeLines = setup$aactiveLines
        STORE :pattern = setup$apattern
        STORE :rampStep = setup$arampStep
    }
    METHOD/Action calculate$setXY__ENA ( Bit(widthAddr) x , Bit(heightAddr) y , Bit(1) dataEnable ) {
        ALLOCA Bit(8) _calculate$setXY$b_out
        ALLOCA Bit(8) _calculate$setXY$g_out
        ALLOCA Bit(8) _calculate$setXY$r_out
        ALLOCA Bit(4) _calculate$setXY$zero
        LET Bit(8) ((((calculate$setXY$y) == (0)) & ((calculate$setXY$dataEnable) & ((pattern) == (1)))) | (((calculate$setXY$x) == (0)) & (!((calculate$setXY$y) == (0)) & ((calculate$setXY$dataEnable) & ((pattern) == (1))))) | (((calculate$setXY$x) == (activePixels)) & (!((calculate$setXY$x) == (0)) & (!((calculate$setXY$y) == (0)) & ((calculate$setXY$dataEnable) & ((pattern) == (1)))))) | (((calculate$setXY$y) == (activeLines)) & (!((calculate$setXY$x) == (activePixels)) & (!((calculate$setXY$x) == (0)) & (!((calculate$setXY$y) == (0)) & ((calculate$setXY$dataEnable) & ((pattern) == (1)))))))):_calculate$setXY$r_out = 255
        LET Bit(8) ((!(calculate$setXY$dataEnable) & ((pattern) == (1))) | (!((calculate$setXY$y) == (activeLines)) & (!((calculate$setXY$x) == (activePixels)) & (!((calculate$setXY$x) == (0)) & (!((calculate$setXY$y) == (0)) & ((calculate$setXY$dataEnable) & ((pattern) == (1)))))))):_calculate$setXY$r_out = 0
        LET Bit(8) ((((calculate$setXY$x) & (1)) != (0)) & ((calculate$setXY$dataEnable) & (((pattern) == (2)) & !((pattern) == (1))))):_calculate$setXY$r_out = 255
        LET Bit(8) ((!(calculate$setXY$dataEnable) & (((pattern) == (2)) & !((pattern) == (1)))) | (!(((calculate$setXY$x) & (1)) != (0)) & ((calculate$setXY$dataEnable) & (((pattern) == (2)) & !((pattern) == (1)))))):_calculate$setXY$r_out = 0
        LET Bit(8) ((((calculate$setXY$y) & (1)) != (0)) & ((calculate$setXY$dataEnable) & (((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1)))))):_calculate$setXY$r_out = 255
        LET Bit(8) ((!(calculate$setXY$dataEnable) & (((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1))))) | (!(((calculate$setXY$y) & (1)) != (0)) & ((calculate$setXY$dataEnable) & (((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1))))))):_calculate$setXY$r_out = 0
        LET Bit(8) (((pattern) == (4)) & (!((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1))))):_calculate$setXY$r_out = __bitsubstr{rampValue,((8) + (12)) - (1),12}
        STORE ((calculate$setXY$dataEnable) & (((calculate$setXY$x) == (activePixels)) & (((pattern) == (4)) & (!((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1))))))):rampValue = 0
        STORE ((calculate$setXY$dataEnable) & ((!((calculate$setXY$x) == (activePixels)) & (((pattern) == (4)) & (!((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1)))))) | (!(calculate$setXY$dataEnable) & (((calculate$setXY$x) == (activePixels)) & (((pattern) == (4)) & (!((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1))))))))):rampValue = (rampValue) + (rampStep)
        LET Bit(8) (!((pattern) == (4)) & (!((pattern) == (3)) & (!((pattern) == (2)) & !((pattern) == (1))))):_calculate$setXY$r_out = 0
        LET Bit(4) :_calculate$setXY$zero = 0
        LET Bit(8) :_calculate$setXY$g_out = _calculate$setXY$r_out
        LET Bit(8) :_calculate$setXY$b_out = _calculate$setXY$r_out
        STORE :pixelValue = __bitconcat{_calculate$setXY$r_out,_calculate$setXY$zero,_calculate$setXY$g_out,_calculate$setXY$zero,_calculate$setXY$b_out,_calculate$setXY$zero}
    }
    METHOD data Bit(36) = ((pixelValue))
}
MODULE HdmiSync(widthAddr=12,heightAddr=12) HdmiSyncIfc(widthAddr=12,heightAddr=12) {
    FILE hdmi_OC_cpp
    FIELD Bit(12) hEnd
    FIELD Bit(12) hFrontEnd
    FIELD Bit(12) hBackSync
    FIELD Bit(12) hSyncWidth
    FIELD Bit(12) vEnd
    FIELD Bit(12) vFrontEnd
    FIELD Bit(12) vBackSync
    FIELD Bit(12) vSyncWidth
    FIELD Bit(12) pixelCount
    FIELD Bit(12) lineCount
    FIELD Bit(1) run
    METHOD dataEnable Bit(1) = (((run) && ((lineCount) >= (vBackSync)) && ((lineCount) <= (vFrontEnd)) && ((pixelCount) >= (hBackSync)) && ((pixelCount) <= (hFrontEnd))))
    METHOD hSync Bit(1) = (((pixelCount) < (hSyncWidth)))
    METHOD vSync Bit(1) = (((lineCount) < (vSyncWidth)))
    METHOD/Action setup__ENA ( Bit(widthAddr) ahEnd , Bit(widthAddr) ahFrontEnd , Bit(widthAddr) ahBackSync , Bit(widthAddr) ahSyncWidth , Bit(heightAddr) avEnd , Bit(heightAddr) avFrontEnd , Bit(heightAddr) avBackSync , Bit(heightAddr) avSyncWidth ) {
        STORE :hEnd = setup$ahEnd
        STORE :hFrontEnd = setup$ahFrontEnd
        STORE :hBackSync = setup$ahBackSync
        STORE :hSyncWidth = setup$ahSyncWidth
        STORE :vEnd = setup$avEnd
        STORE :vFrontEnd = setup$avFrontEnd
        STORE :vBackSync = setup$avBackSync
        STORE :vSyncWidth = setup$avSyncWidth
        STORE :run = 1
    }
    METHOD/Rule/Action RULE$updatePixel__ENA if ((run)) {
        STORE ((pixelCount) < (hEnd)):pixelCount = (pixelCount) + (1)
        STORE !((pixelCount) < (hEnd)):pixelCount = 0
        STORE (((lineCount) == (vEnd)) & !((pixelCount) < (hEnd))):lineCount = 0
        STORE (!((lineCount) == (vEnd)) & !((pixelCount) < (hEnd))):lineCount = (lineCount) + (1)
        CALL/Action :data$setXY__ENA{(pixelCount) - (hBackSync),(lineCount) - (vBackSync),((run) && ((lineCount) >= (vBackSync)) && ((lineCount) <= (vFrontEnd)) && ((pixelCount) >= (hBackSync)) && ((pixelCount) <= (hFrontEnd))) != (0)}
    }
}
