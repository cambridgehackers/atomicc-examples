
#pragma GCC system_header
#include <bits/c++config.h>
//#include <bits/stl_function.h>
#include <new>
#include <tuple>

namespace std {
template<typename T>
   struct zzremove_reference { typedef T     type; };
template <class T>
   typename zzremove_reference<T>::type&
   zzmove(T& a)
   {
       return a;
   }
  template<typename _Signature> class function;
  template<typename _Signature, typename _Functor> class _Function_handler;
  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor> {
    public:
        static _Res _M_invoke(void * __functor, _ArgTypes... __args) {
          return (*(_Functor *)__functor)( std::forward<_ArgTypes>(__args)...);
        }
    };
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)> {
    public:
      typedef _Res (*MFUN)(_ArgTypes...);
      template<typename _Functor> function(_Functor __f);
      _Res (*_M_invoker)(void *, _ArgTypes...);
      void *_M_functor;
      MFUN func2;
    };
  template<typename _Res, typename... _ArgTypes> template<typename _Functor> function<_Res(_ArgTypes...)>::
      function(_Functor __f) {
        typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;
        _M_invoker = &_My_handler::_M_invoke;
        // uses 'placement new'
        //new (_M_functor) _Functor(std::move(__f));
        new (_M_functor) _Functor(zzmove(__f));
        func2 = (MFUN) _M_functor;
      }
} // namespace std
